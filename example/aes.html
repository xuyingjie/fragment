<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>AES</title>
</head>

<body>

  <script type="text/javascript">
    // 16 x 8 = 128;
    // 8 x 16
    //
    // WebCryptoAPI
    //
    function importKey(str, callback) {
      'use strict';
      window.crypto.subtle.importKey(
        "raw", //can be "jwk" or "raw"
        strToArrayBuffer(str), { //this is the algorithm options
          name: "AES-GCM",
        },
        false, //whether the key is extractable (i.e. can be used in exportKey)
        ["encrypt", "decrypt"] //can "encrypt", "decrypt", "wrapKey", or "unwrapKey"
      )
        .then(key => {
          //returns the symmetric key
          callback(key);
        })
        .catch(err => {
          console.error(err);
        });
    }

    function encrypt(opt) {
      'use strict';
      importKey(opt.passwd, key => {
        window.crypto.subtle.encrypt({
          name: "AES-GCM",

          //Don't re-use initialization vectors!
          //Always generate a new iv every time your encrypt!
          //Recommended to use 12 bytes length
          iv: strToArrayBuffer(opt.iv),

          //Additional authentication data (optional)
          // additionalData: ArrayBuffer,

          //Tag length (optional)
          tagLength: 128, //can be 32, 64, 96, 104, 112, 120 or 128 (default)
        },
          key, //from generateKey or importKey above
          opt.data //ArrayBuffer of data you want to encrypt
        )
          .then(encrypted => {
            //returns an ArrayBuffer containing the encrypted data
            opt.callback(encrypted);
          })
          .catch(err => {
            console.error(err);
          });
      });
    }

    function decrypt(opt) {
      'use strict';
      importKey(opt.passwd, key => {
        window.crypto.subtle.decrypt({
          name: "AES-GCM",
          iv: strToArrayBuffer(opt.iv), //The initialization vector you used to encrypt
          // additionalData: ArrayBuffer, //The addtionalData you used to encrypt (if any)
          tagLength: 128, //The tagLength you used to encrypt (if any)
        },
          key, //from generateKey or importKey above
          opt.data //ArrayBuffer of the data
        )
          .then(decrypted => {
            //returns an ArrayBuffer containing the decrypted data
            opt.callback(decrypted);
          })
          .catch(err => {
            console.error(err);
          });
      });
    }

    encrypt({
      passwd: 'erdswedf',
      iv: 'erdswe',
      data: strToArrayBuffer('你好'),
      callback: decrypted => {
        'use strict';
        console.log(decrypted);
        decrypt({
          passwd: 'erdswedf',
          iv: 'erdswe',
          data: decrypted,
          callback: decrypted => {
            console.log(arrayBufferToStr(decrypted));
          }
        });
      }
    });



    function arrayBufferToStr(buf) {
      'use strict';
      return String.fromCharCode.apply(null, new Uint16Array(buf));
    }

    function strToArrayBuffer(str) {
      'use strict';

      var buf = new ArrayBuffer(str.length * 2);
      var bufView = new Uint16Array(buf);
      for (var i = 0, strLen = str.length; i < strLen; i++) {
        // console.log(str.charCodeAt(i));
        bufView[i] = str.charCodeAt(i);
      }
      return buf;
    }
  </script>
</body>

</html>
